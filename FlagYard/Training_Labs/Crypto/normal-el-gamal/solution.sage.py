

# This file was *autogenerated* from the file solution.sage
from sage.all_cmdline import *   # import sage library

_sage_const_8 = Integer(8); _sage_const_23502 = Integer(23502); _sage_const_1 = Integer(1); _sage_const_4 = Integer(4); _sage_const_0 = Integer(0)# solve_remote.py
#
# Run with:
#   sage -python solve_remote.py
#
from sage.all import *
from pwn import remote
from Crypto.Util.number import long_to_bytes
import re
import random

# ======================
# FILL THESE PARAMETERS
# ======================
# These are the curve / group params from the challenge (usually in the task text or files)
p  = Ellipsis        # prime modulus for GF(p)
a  = Ellipsis        # curve parameter a
b  = Ellipsis        # curve parameter b
n  = Ellipsis        # order of base point G
gx = Ellipsis        # g[0]
gy = Ellipsis        # g[1]

L_BITS = _sage_const_8       # as in challenge

def main():
    # --- connect to remote instance ---
    r = remote("tcp.flagyard.com", _sage_const_23502 )

    # read until we see the line with ct=
    banner = b""
    while b"ct=" not in banner:
        line = r.recvline()
        banner += line

    # extract ct=(...)
    m = re.search(rb"ct=\(([^)]*)\)", banner)
    if not m:
        print("[-] Couldn't find ct= in banner")
        return
    nums = list(map(int, m.group(_sage_const_1 ).split(b",")))
    if len(nums) != _sage_const_4 :
        print("[-] Unexpected ct length")
        return

    c1x, c1y, c2x, c2y = nums
    print("[*] Got ct:")
    print("    c1x =", c1x)
    print("    c1y =", c1y)
    print("    c2x =", c2x)
    print("    c2y =", c2y)

    # --- rebuild curve & points locally ---
    Fp = GF(p)
    E  = EllipticCurve(Fp, [a, b])
    G  = E(gx, gy)

    C1 = E(c1x, c1y)
    C2 = E(c2x, c2y)

    order = n if n is not None else E.order()

    # --- choose random R = r * G and compute C2' = C2 + R ---
    while True:
        r_scalar = random.randint(_sage_const_1 , order - _sage_const_1 )
        R = r_scalar * G
        C2_prime = C2 + R

        # avoid hitting the "same C2.x or C2.y" filters
        if int(C2_prime[_sage_const_0 ]) != c2x and int(C2_prime[_sage_const_1 ]) != c2y:
            break

    c2x_p = int(C2_prime[_sage_const_0 ])
    c2y_p = int(C2_prime[_sage_const_1 ])

    print("[*] Crafted modified ciphertext (reusing C1, changing C2):")
    print(f"    ({c1x},{c1y},{c2x_p},{c2y_p})")

    # --- drive menu: choose '2. dec' and send modified ct ---
    # The banner likely already printed the menu; just wait for >> prompt
    data = b""
    while b">>" not in data:
        data += r.recv(_sage_const_1 )

    r.sendline(b"2")     # choose dec
    r.recvuntil(b"ciphertext>>")
    payload = f"{c1x},{c1y},{c2x_p},{c2y_p}".encode()
    r.sendline(payload)

    # read until we get the "m= " line
    line = r.recvline()
    while b"m=" not in line:
        line = r.recvline()
    print("[*] Oracle response:", line.strip())

    # parse: m=  mx my
    # Example: b"m=  123 456\n"
    m_part = line.split(b"m=")[_sage_const_1 ].strip()
    mx_bytes, my_bytes = m_part.split()
    mx = int(mx_bytes)
    my = int(my_bytes)

    # --- reconstruct M' = M + R, then M = M' - R ---
    M_plus_R = E(mx, my)
    M = M_plus_R - R

    x_M = int(M[_sage_const_0 ])
    m_int = x_M >> L_BITS
    flag = long_to_bytes(m_int)

    print("[+] Recovered message integer m_int =", m_int)
    print("[+] FLAG bytes:", flag)
    try:
        print("[+] FLAG string:", flag.decode())
    except UnicodeDecodeError:
        print("[+] FLAG is not nice UTF-8, raw bytes above.")

    r.close()

if __name__ == "__main__":
    main()

