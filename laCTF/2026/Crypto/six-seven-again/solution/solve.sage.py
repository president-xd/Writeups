

# This file was *autogenerated* from the file super67/solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_65537 = Integer(65537); _sage_const_134 = Integer(134); _sage_const_67 = Integer(67); _sage_const_10 = Integer(10); _sage_const_9 = Integer(9); _sage_const_0p05 = RealNumber('0.05'); _sage_const_0p03 = RealNumber('0.03'); _sage_const_0p02 = RealNumber('0.02'); _sage_const_0p01 = RealNumber('0.01'); _sage_const_0p49 = RealNumber('0.49'); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_8 = Integer(8)#!/usr/bin/env sage
# Solve super-67-prime RSA given n and c
# Usage: sage solve.sage <n> <c>
import sys

if len(sys.argv) < _sage_const_3 :
    print("Usage: sage solve.sage <n> <c>")
    sys.exit(_sage_const_1 )

n = int(sys.argv[_sage_const_1 ])
c = int(sys.argv[_sage_const_2 ])
e = _sage_const_65537 

print(f"[*] n is {int(n).bit_length()} bits")

# p = "6"*67 + middle + "7"*67, where middle digits are each 6 or 7
# Let p = base + delta * 10^67 where base = int("6"*134 + "7"*67)
# delta ranges from 0 to (10^67-1)/9 (=repunit(67)) ~ 2^219

base = int("6"*_sage_const_134  + "7"*_sage_const_67 )

P = PolynomialRing(Zmod(n), names=('x',)); (x,) = P._first_ngens(1)
# f(x) = base + x*10^67  has root delta mod p, which divides n
# Make monic: divide by 10^67
inv_coeff = inverse_mod(int(_sage_const_10 **_sage_const_67 ), n)
f_monic = x + int(base) * inv_coeff
X = (_sage_const_10 **_sage_const_67  - _sage_const_1 ) // _sage_const_9  + _sage_const_1 

print(f"[*] Running Coppersmith (X ~ 2^{int(X).bit_length()} bits)...")
print("[*] This may take a minute...")

# Try with increasing epsilon (larger = faster but less likely to succeed)
for eps in [_sage_const_0p05 , _sage_const_0p03 , _sage_const_0p02 , _sage_const_0p01 ]:
    print(f"[*] Trying epsilon={eps}...")
    try:
        roots = f_monic.small_roots(X=X, beta=_sage_const_0p49 , epsilon=eps)
        if roots:
            print(f"[*] Found {len(roots)} root(s) with eps={eps}")
            break
    except Exception as ex:
        print(f"[*] eps={eps} failed: {ex}")
        continue
else:
    print("[-] No roots found with any parameters")
    sys.exit(_sage_const_1 )

for r in roots:
    delta = int(r)
    p_cand = base + delta * _sage_const_10 **_sage_const_67 
    if n % p_cand == _sage_const_0 :
        q = n // p_cand
        phi = (p_cand - _sage_const_1 ) * (q - _sage_const_1 )
        d = int(inverse_mod(e, phi))
        m = int(pow(c, d, n))
        flag = m.to_bytes((m.bit_length() + _sage_const_7 ) // _sage_const_8 , 'big')
        print(f"\n[+] p = {p_cand}")
        print(f"[+] q = {q}")
        try:
            print(f"[+] FLAG: {flag.decode()}")
        except:
            print(f"[+] FLAG (bytes): {flag}")
        sys.exit(_sage_const_0 )

print("[-] Root found but doesn't divide n")

