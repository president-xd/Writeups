#!/usr/bin/env python3
"""
Orchestrator for ZK permutation challenge exploit.
Runs the C++ binary for each connection, collects extracted data,
solves the system, and submits the answer.
"""

import subprocess
import sys
import os
import time

HOST = "chall.lac.tf"
PORT = "31183"
BIN = "/mnt/d/LA-CTF/test_arith_client"
LIB_PATH = "/mnt/d/LA-CTF/local_lib:/mnt/d/LA-CTF/empzk_build"

PR = (1 << 61) - 1  # 2^61 - 1

def add_p(a, b):
    return (a + b) % PR

def sub_p(a, b):
    return (a - b) % PR

def mul_p(a, b):
    return (a * b) % PR

def pow_p(base, exp):
    return pow(base, exp, PR)

def inv_p(a):
    return pow_p(a, PR - 2)

def run_extract(X):
    """Run one extract connection, return (delta, ka, kb, kc, L, X)"""
    print(f"  Running extract X={X}...", file=sys.stderr)
    env = os.environ.copy()
    env["LD_LIBRARY_PATH"] = LIB_PATH
    cmd = [BIN, HOST, PORT, "extract", str(X)]
    result = subprocess.run(cmd, capture_output=True, text=True, timeout=90, env=env)
    if result.returncode != 0:
        print(f"  STDERR: {result.stderr}", file=sys.stderr)
        raise RuntimeError(f"Extract failed with code {result.returncode}")
    line = result.stdout.strip()
    print(f"  STDERR: {result.stderr.strip()}", file=sys.stderr)
    if not line:
        raise RuntimeError("No output from extract")
    parts = line.split()
    if len(parts) != 6:
        raise RuntimeError(f"Unexpected output: {line}")
    delta, ka, kb, kc, L, X_out = [int(x) for x in parts]
    print(f"  Got: delta={delta} ka={ka} kb={kb} kc={kc} L={L}", file=sys.stderr)
    return {'delta': delta, 'ka': ka, 'kb': kb, 'kc': kc, 'L': L, 'X': X_out}


def run_submit(guesses):
    """Run submit connection, return flag"""
    print(f"  Submitting guesses: {guesses}", file=sys.stderr)
    env = os.environ.copy()
    env["LD_LIBRARY_PATH"] = LIB_PATH
    cmd = [BIN, HOST, PORT, "submit"] + [str(g) for g in guesses]
    result = subprocess.run(cmd, capture_output=True, text=True, timeout=90, env=env)
    print(f"  STDERR: {result.stderr.strip()}", file=sys.stderr)
    for line in result.stdout.strip().split('\n'):
        if line.startswith("FLAG:"):
            return line[5:]
    raise RuntimeError(f"No flag in output: {result.stdout}")


def solve_quadratic_for_v(d1, d2):
    """
    Given two extractions with the same X:
    L = delta*u*v + kb*u + ka*v
    Solve for v by eliminating u.
    """
    D1, D2 = d1['delta'], d2['delta']
    ka1, ka2 = d1['ka'], d2['ka']
    kb1, kb2 = d1['kb'], d2['kb']
    L1, L2 = d1['L'], d2['L']

    # From cross-multiply to eliminate u:
    # (ka2*D1 - ka1*D2)*v^2 + (L1*D2 - L2*D1 + ka2*kb1 - ka1*kb2)*v + (L1*kb2 - L2*kb1) = 0
    A = sub_p(mul_p(ka2, D1), mul_p(ka1, D2))
    B = add_p(sub_p(mul_p(L1, D2), mul_p(L2, D1)),
              sub_p(mul_p(ka2, kb1), mul_p(ka1, kb2)))
    C = sub_p(mul_p(L1, kb2), mul_p(L2, kb1))

    print(f"  Quadratic: A={A} B={B} C={C}", file=sys.stderr)

    if A == 0:
        if B == 0:
            return []
        return [mul_p(sub_p(0, C), inv_p(B))]

    # Discriminant
    disc = sub_p(mul_p(B, B), mul_p(4, mul_p(A, C)))
    
    if disc == 0:
        v = mul_p(sub_p(0, B), inv_p(mul_p(2, A)))
        return [v % PR]

    # Check quadratic residue: leg = disc^((p-1)/2) should be 1
    leg = pow_p(disc, (PR - 1) // 2)
    if leg != 1:
        print(f"  WARNING: discriminant {disc} is non-residue!", file=sys.stderr)
        return []

    # sqrt(disc) = disc^((p+1)/4) since p â‰¡ 3 mod 4
    sq = pow_p(disc, (PR + 1) // 4)
    inv2A = inv_p(mul_p(2, A) % PR)
    negB = sub_p(0, B)

    v1 = mul_p(add_p(negB, sq), inv2A)
    v2 = mul_p(sub_p(negB, sq), inv2A)
    return [v1 % PR, v2 % PR]


def compute_u(d, v):
    """Given leak data and known v, compute u = (L - ka*v) / (delta*v + kb)"""
    num = sub_p(d['L'], mul_p(d['ka'], v))
    den = add_p(mul_p(d['delta'], v), d['kb'])
    if den == 0:
        return None
    return mul_p(num, inv_p(den))


def verify_v(d, v):
    """Check: L == delta*u*v + kb*u + ka*v"""
    u = compute_u(d, v)
    if u is None:
        return False
    check = add_p(mul_p(d['delta'], mul_p(u, v)),
                  add_p(mul_p(d['kb'], u), mul_p(d['ka'], v)))
    return check == d['L']


def poly_eval(coeffs, x):
    """Evaluate polynomial with coefficients in ascending order"""
    result = 0
    xpow = 1
    for c in coeffs:
        result = add_p(result, mul_p(c, xpow))
        xpow = mul_p(xpow, x)
    return result


def lagrange_interpolate(points):
    """Given list of (x, y) points, return polynomial coefficients (ascending degree)"""
    n = len(points)
    # Direct computation using numpy-like approach but over F_p
    # Basis polynomial approach
    result = [0] * n  # degree n-1
    
    for i in range(n):
        xi, yi = points[i]
        # Compute basis polynomial L_i = prod((x - xj) / (xi - xj), j != i)
        basis = [1]  # starts as constant 1
        denom = 1
        for j in range(n):
            if j == i:
                continue
            xj = points[j][0]
            # Multiply basis by (x - xj): [c0, c1, ...] -> [-xj*c0, c0-xj*c1, c1-xj*c2, ...]
            new_basis = [0] * (len(basis) + 1)
            for k in range(len(basis)):
                new_basis[k] = add_p(new_basis[k], mul_p(PR - xj, basis[k]))
                new_basis[k + 1] = add_p(new_basis[k + 1], basis[k])
            basis = new_basis
            denom = mul_p(denom, sub_p(xi, xj))
        
        coeff = mul_p(yi, inv_p(denom))
        for k in range(len(basis)):
            if k < len(result):
                result[k] = add_p(result[k], mul_p(coeff, basis[k]))
    
    # Trim trailing zeros
    while len(result) > 1 and result[-1] == 0:
        result.pop()
    return result


def poly_mul(a, b):
    if not a or not b:
        return [0]
    c = [0] * (len(a) + len(b) - 1)
    for i in range(len(a)):
        for j in range(len(b)):
            c[i + j] = add_p(c[i + j], mul_p(a[i], b[j]))
    return c


def poly_mod(a, b):
    """a mod b"""
    da = len(a) - 1
    while da >= 0 and a[da] == 0:
        da -= 1
    db = len(b) - 1
    while db >= 0 and b[db] == 0:
        db -= 1
    if da < db:
        return a[:]
    r = a[:]
    inv_lead = inv_p(b[db])
    for i in range(da, db - 1, -1):
        if r[i] == 0:
            continue
        coeff = mul_p(r[i], inv_lead)
        for j in range(db + 1):
            r[i - db + j] = sub_p(r[i - db + j], mul_p(coeff, b[j]))
    # Trim
    while len(r) > 1 and r[-1] == 0:
        r.pop()
    return r


def poly_gcd(a, b):
    while True:
        db = len(b) - 1
        while db >= 0 and b[db] == 0:
            db -= 1
        if db < 0:
            break
        a, b = b, poly_mod(a, b)
    # Make monic
    da = len(a) - 1
    while da >= 0 and a[da] == 0:
        da -= 1
    if da >= 0:
        inv_lead = inv_p(a[da])
        a = [mul_p(c, inv_lead) for c in a]
    return a


def poly_powmod(base, exp, modpoly):
    result = [1]
    base = poly_mod(base, modpoly)
    while exp > 0:
        if exp & 1:
            result = poly_mod(poly_mul(result, base), modpoly)
        base = poly_mod(poly_mul(base, base), modpoly)
        exp >>= 1
    return result


def find_roots(P):
    """Find all roots of polynomial P over F_p using Cantor-Zassenhaus"""
    import random
    rng = random.Random(42)
    
    # Step 1: gcd(P, x^p - x) gives product of all linear factors
    x = [0, 1]  # polynomial x
    xp = poly_powmod(x, PR, P)
    # x^p - x
    xpx = xp[:]
    while len(xpx) < 2:
        xpx.append(0)
    xpx[1] = sub_p(xpx[1], 1)
    
    g = poly_gcd(P, xpx)
    # g is product of all linear factors
    
    def split(g):
        dg = len(g) - 1
        while dg >= 0 and g[dg] == 0:
            dg -= 1
        if dg <= 0:
            return []
        if dg == 1:
            # g = g[0] + g[1]*x, root = -g[0]/g[1]
            return [sub_p(0, mul_p(g[0], inv_p(g[1])))]
        
        for _ in range(100):
            r = rng.randint(0, PR - 1)
            xr = [r, 1]
            h = poly_powmod(xr, (PR - 1) // 2, g)
            # h - 1
            h[0] = sub_p(h[0], 1)
            factor = poly_gcd(g, h)
            df = len(factor) - 1
            while df >= 0 and factor[df] == 0:
                df -= 1
            if 0 < df < dg:
                roots1 = split(factor)
                # quotient = g / factor
                quotient = poly_div(g, factor)
                roots2 = split(quotient)
                return roots1 + roots2
        return []
    
    def poly_div(a, b):
        """a / b (exact division)"""
        da = len(a) - 1
        while da >= 0 and a[da] == 0:
            da -= 1
        db = len(b) - 1
        while db >= 0 and b[db] == 0:
            db -= 1
        if da < db:
            return [0]
        q = [0] * (da - db + 1)
        r = a[:]
        inv_lead = inv_p(b[db])
        for i in range(da, db - 1, -1):
            if r[i] == 0:
                continue
            coeff = mul_p(r[i], inv_lead)
            q[i - db] = coeff
            for j in range(db + 1):
                r[i - db + j] = sub_p(r[i - db + j], mul_p(coeff, b[j]))
        return q
    
    return split(g)


def main():
    print("=== ZK Permutation Challenge Exploit ===", file=sys.stderr)
    
    # Phase 1: 3 connections with X=1 to solve for v = vec2[9]+1
    print("\n--- Phase 1: Extract (3 connections with X=1) ---", file=sys.stderr)
    phase1 = []
    for i in range(3):
        d = run_extract(1)
        phase1.append(d)
        time.sleep(5)  # Wait for server process to die
    
    # Solve quadratic for v
    v_candidates = solve_quadratic_for_v(phase1[0], phase1[1])
    print(f"  v candidates: {v_candidates}", file=sys.stderr)
    
    if not v_candidates:
        print("ERROR: No solutions for v!", file=sys.stderr)
        sys.exit(1)
    
    # Verify with third connection
    v_correct = None
    for v in v_candidates:
        if verify_v(phase1[2], v):
            v_correct = v
            print(f"  Verified v = {v}", file=sys.stderr)
            break
    
    if v_correct is None:
        print("  WARNING: No candidate verified, trying first...", file=sys.stderr)
        v_correct = v_candidates[0]
    
    # vec2[9] = v - X = v - 1
    vec2_9 = sub_p(v_correct, 1)
    print(f"  vec2[9] = {vec2_9}", file=sys.stderr)
    
    # Compute P(1) from first connection
    u_at_1 = compute_u(phase1[0], v_correct)
    P_at_1 = mul_p(u_at_1, v_correct)  # P(1) = u * v = prod(vec2[i]+1)
    print(f"  u(1) = {u_at_1}, P(1) = {P_at_1}", file=sys.stderr)
    
    # Phase 2: 9 connections with X=2..10
    print("\n--- Phase 2: Extract (X=2..10) ---", file=sys.stderr)
    P_evals = [(1, P_at_1)]
    
    for X in range(2, 11):
        d = run_extract(X)
        v_x = add_p(vec2_9, X)  # vec2[9] + X
        u_x = compute_u(d, v_x)
        P_x = mul_p(u_x, v_x)
        P_evals.append((X, P_x))
        print(f"  P({X}) = {P_x}", file=sys.stderr)
        time.sleep(5)
    
    # Phase 3: Interpolate and find roots
    print("\n--- Phase 3: Interpolate polynomial ---", file=sys.stderr)
    
    # P(X) is degree 10 monic. Q(X) = P(X) - X^10 has degree <= 9.
    Q_evals = []
    for xi, pi in P_evals:
        x10 = pow_p(xi, 10)
        Q_evals.append((xi, sub_p(pi, x10)))
    
    Q_poly = lagrange_interpolate(Q_evals)
    
    # P(X) = Q(X) + X^10
    P_poly = Q_poly + [0] * (11 - len(Q_poly))
    P_poly[10] = add_p(P_poly[10], 1)
    
    print(f"  P(X) degree: {len(P_poly)-1}", file=sys.stderr)
    
    # Verify: P(1) should match
    check = poly_eval(P_poly, 1)
    print(f"  Verify P(1): computed={check} expected={P_at_1} match={check == P_at_1}", file=sys.stderr)
    
    # Find roots
    print("  Finding roots (this may take a moment)...", file=sys.stderr)
    roots = find_roots(P_poly)
    print(f"  Found {len(roots)} roots", file=sys.stderr)
    
    # Convert roots to vec2 values
    vec2 = []
    for r in roots:
        val = sub_p(0, r)  # vec2[i] = -root
        vec2.append(val)
        print(f"  root={r} -> vec2 element={val}", file=sys.stderr)
    
    if len(vec2) != 10:
        print(f"ERROR: Found {len(vec2)} elements instead of 10!", file=sys.stderr)
        # Try brute force for small values
        print("  Trying brute force for remaining roots...", file=sys.stderr)
        for c in range(10**6):
            neg_c = sub_p(0, c)
            if poly_eval(P_poly, neg_c) == 0:
                if c not in vec2:
                    vec2.append(c)
                    print(f"  Brute force: found {c}", file=sys.stderr)
                    if len(vec2) == 10:
                        break
    
    if len(vec2) != 10:
        print(f"FATAL: Only found {len(vec2)} elements: {vec2}", file=sys.stderr)
        sys.exit(1)
    
    print(f"\n=== SOLUTION: vec2 = {vec2} ===", file=sys.stderr)
    
    # Phase 4: Submit
    print("\n--- Phase 4: Submit ---", file=sys.stderr)
    time.sleep(5)
    flag = run_submit(vec2)
    print(f"\n{'='*50}", file=sys.stderr)
    print(f"FLAG: {flag}", file=sys.stderr)
    print(f"{'='*50}", file=sys.stderr)
    print(flag)


if __name__ == "__main__":
    main()
